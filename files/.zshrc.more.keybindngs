# Delete from cursor to next separator (&&, ||, ;) including following spaces
kill_to_next_sep() {
  local buf="$BUFFER"
  local cur=$CURSOR
  local len=${#buf}

  # If cursor is at or beyond end of line, nothing to do
  (( cur >= len )) && return

  # Part of buffer after the cursor (1-based indexing in zsh)
  local after=${buf[cur+1,-1]}
  local after_len=${#after}

  local best_idx=-1    # position (1-based) of chosen separator within "after"
  local sep_len=0      # length of chosen separator
  local sep prefix pos

  # 1) Find the closest separator among: &&, ||, ;
  for sep in '&&' '||' ';'; do
    if [[ $after == *"$sep"* ]]; then
      prefix=${after%%"$sep"*}
      pos=$(( ${#prefix} + 1 ))  # first char position of this sep in "after"
      if (( best_idx == -1 || pos < best_idx )); then
        best_idx=$pos
        sep_len=${#sep}
      fi
    fi
  done

  # 2) If no separator found → delete to end of line (kill-line behavior)
  if (( best_idx == -1 )); then
    BUFFER="${buf[1,cur]}"
    CURSOR=$cur
    return
  fi

  # 3) Extend forward to include following spaces/tabs after the separator
  local i=$(( best_idx + sep_len ))
  local ch
  while (( i <= after_len )); do
    ch=${after[i]}
    [[ $ch == ' ' || $ch == $'\t' ]] || break
    (( i++ ))
  done

  # Delete from cursor to (cursor + i - 1) in the original buffer
  local abs_end=$(( cur + i - 1 ))

  # Keep: [1..cur] + [abs_end+1..end]
  BUFFER="${buf[1,cur]}${buf[abs_end+1,-1]}"
  CURSOR=$cur
}

# Delete from cursor backward to previous separator (&&, ||, ;) including leading spaces
kill_to_prev_sep() {
  local buf="$BUFFER"
  local cur=$CURSOR

  # If cursor is at start of line, nothing to do
  (( cur <= 0 )) && return

  # Part of buffer before the cursor (1-based indexing)
  local pre=${buf[1,cur]}
  local pre_len=${#pre}

  local best_idx=-1    # position (1-based) of chosen separator within "pre"
  local sep_len=0
  local sep prefix pos

  # 1) Find the closest separator to the left among: &&, ||, ;
  for sep in '&&' '||' ';'; do
    if [[ $pre == *"$sep"* ]]; then
      # last occurrence position
      prefix=${pre%$sep*}
      pos=$(( ${#prefix} + 1 ))  # first char position of this sep in "pre"
      if (( best_idx == -1 || pos > best_idx )); then
        best_idx=$pos
        sep_len=${#sep}
      fi
    fi
  done

  # 2) If no separator found → delete from line start to cursor (backward-kill-line)
  if (( best_idx == -1 )); then
    BUFFER="${buf[cur+1,-1]}"
    CURSOR=0
    return
  fi

  # 3) Extend backward to include leading spaces/tabs before the separator
  local left=$best_idx
  local ch
  while (( left > 1 )); do
    ch=${pre[left-1]}
    [[ $ch == ' ' || $ch == $'\t' ]] || break
    (( left-- ))
  done

  # Delete from "left" to "cur" (both inclusive) in the original buffer
  local keep_end=$(( left - 1 ))
  BUFFER="${buf[1,keep_end]}${buf[cur+1,-1]}"

  # Cursor goes to end of kept prefix
  CURSOR=$keep_end
}

zle -N kill_to_next_sep
zle -N kill_to_prev_sep

bindkey -r $'\eD' 2>/dev/null
bindkey -r $'\e\x7f' 2>/dev/null
bindkey $'\eD' kill_to_next_sep
bindkey $'\e\x7f' kill_to_prev_sep

# Capture command line and exit when running in tmux popup capture mode
if [[ -n "${TMUX_POPUP_CAPTURE_FILE:-}" ]]; then
  __tmux_popup_capture_and_exit() {
    print -r -- "$BUFFER" >| "$TMUX_POPUP_CAPTURE_FILE"
    zle -I
    exit 0
  }
  zle -N accept-line __tmux_popup_capture_and_exit
fi

fzf-insert-from-tmux-popup() {
  local out cmd tmpdir cmdfile

  zle -I
  tmux delete-buffer -b fzf_insert 2>/dev/null || true

  tmpdir="$(mktemp -d -t tmux_popup_capture.XXXXXX)" || { zle reset-prompt; return 0; }
  cmdfile="$tmpdir/cmd"

  # Popup #1: normal zsh startup (same prompt/history), Enter captures BUFFER and exits
  tmux popup -E -d "$PWD" -w 90% -h 70% \
    "TMUX_POPUP_CAPTURE_FILE='$cmdfile' zsh -i" >/dev/null 2>&1

  cmd="$(<"$cmdfile" 2>/dev/null)" || cmd=""
  rm -rf -- "$tmpdir"

  [[ -n "$cmd" ]] || { zle reset-prompt; return 0; }

  # Popup #2: run cmd and fzf in popup; write selection to tmux buffer
  tmux delete-buffer -b fzf_insert 2>/dev/null || true
  tmux popup -E -w 90% -h 70% "zsh -i -c '
    sel=\"\$(eval ${(qqq)cmd} | fzf)\" || exit 0
    [[ -n \"\$sel\" ]] || exit 0
    print -rn -- \"\$sel\" | tmux load-buffer -b fzf_insert -
  '" >/dev/null 2>&1

  out="$(tmux save-buffer -b fzf_insert - 2>/dev/null)" || { zle reset-prompt; return 0; }
  [[ -n "$out" ]] || { zle reset-prompt; return 0; }

  LBUFFER+="$out"
  zle reset-prompt
}

zle -N fzf-insert-from-tmux-popup
bindkey '^[f' fzf-insert-from-tmux-popup
